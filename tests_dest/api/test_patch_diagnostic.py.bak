# Add path setup to find the tests_dest module
import sys
import os
from pathlib import Path

# Add parent directory to path so Python can find the tests_dest module
current_dir = Path(__file__).resolve().parent
parent_dir = current_dir.parent.parent  # Go up two levels to reach project root
if str(parent_dir) not in sys.path:
    sys.path.insert(0, str(parent_dir))

# Import helper to fix path issues
from tests_dest.import_helper import fix_imports
fix_imports()

"""
Diagnostic tests for understanding why patching service getter functions doesn't work with FastAPI dependencies.
"""


import pytest
import logging
import time
import json
from unittest.mock import MagicMock, AsyncMock, patch
from fastapi.testclient import TestClient
from fastapi import Request, Response, FastAPI, HTTPException, Depends
from fastapi.responses import JSONResponse

# Configure logging
logging.basicConfig()
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Custom exception classes
class ValidationError(Exception):
    """Custom validation error."""
    def __init__(self, message, details=None):
        super().__init__(message)
        self.details = details or {}
        
class NotFoundError(Exception):
    """Custom not found error."""
    def __init__(self, message):
        super().__init__(message)


# Mock dependencies for testing
def get_material_service_dependency():
    return Depends(lambda: MagicMock()))

def get_monitor_service_dependency():
    return Depends(lambda: MagicMock()))

# Mock controllers
async def list_materials(request: Request = None):
    return JSONResponse({"materials": ["test"]})

current_dir = Path(__file__).resolve().parent
parent_dir = current_dir.parent.parent  # Go up two levels to reach project root
if str(parent_dir) not in sys.path:
    sys.path.insert(0, str(parent_dir))

# Import helper to fix path issues
from tests_dest.import_helper import fix_imports
fix_imports()




import pytest
import logging
import time
import json
from unittest.mock import MagicMock, AsyncMock, patch
from fastapi.testclient import TestClient
from fastapi import Request, Response, FastAPI, HTTPException, Depends
from fastapi.responses import JSONResponse

# Configure logging
logging.basicConfig()
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Custom exception classes
class ValidationError(Exception):
    """Custom validation error."""
    def __init__(self, message, details=None):
        super().__init__(message)
        self.details = details or {}


# Mock dependencies for testing
def get_material_service_dependency():
    return Depends(lambda: MagicMock()))

def get_monitor_service_dependency():
    return Depends(lambda: MagicMock()))

# Mock controllers
async def list_materials(request: Request = None):
    return JSONResponse({"materials": ["test"]})

current_dir = Path(__file__).resolve().parent
parent_dir = current_dir.parent.parent  # Go up two levels to reach project root
if str(parent_dir) not in sys.path:
    sys.path.insert(0, str(parent_dir))

# Import helper to fix path issues
from tests_dest.import_helper import fix_imports
fix_imports()




import pytest
import logging
import time
import json
from unittest.mock import MagicMock, AsyncMock, patch
from fastapi.testclient import TestClient
from fastapi import Request, Response, FastAPI, HTTPException, Depends
from fastapi.responses import JSONResponse

# Configure logging
logging.basicConfig()
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


# Mock dependencies for testing
def get_material_service_dependency():
    return Depends(lambda: MagicMock()))

def get_monitor_service_dependency():
    return Depends(lambda: MagicMock()))

# Mock controllers
async def list_materials(request: Request = None):
    return JSONResponse({"materials": ["test"]})

current_dir = Path(__file__).resolve().parent
parent_dir = current_dir.parent.parent  # Go up two levels to reach project root
if str(parent_dir) not in sys.path:
    sys.path.insert(0, str(parent_dir))

# Import helper to fix path issues
from tests_dest.import_helper import fix_imports
fix_imports()




import pytest
import logging
from unittest.mock import MagicMock, AsyncMock, patch
from fastapi.testclient import TestClient
from fastapi import Request, Response, FastAPI, HTTPException, Depends
from fastapi.responses import JSONResponse

# Configure logging
logging.basicConfig()
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


# Mock dependencies for testing
def get_material_service_dependency():
    return Depends(lambda: MagicMock()))

def get_monitor_service_dependency():
    return Depends(lambda: MagicMock()))

# Mock controllers
async def list_materials(request: Request = None):
    return JSONResponse({"materials": ["test"]})

current_dir = Path(__file__).resolve().parent
parent_dir = current_dir.parent.parent  # Go up two levels to reach project root
if str(parent_dir) not in sys.path:
    sys.path.insert(0, str(parent_dir))

# Import helper to fix path issues
from tests_dest.import_helper import fix_imports
fix_imports()




import pytest
import logging
from unittest.mock import MagicMock, AsyncMock, patch
from fastapi.testclient import TestClient
from fastapi import Request, Response, FastAPI, HTTPException, Depends

# Configure logging
logging.basicConfig()
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


# Mock dependencies for testing
def get_material_service_dependency():
    return Depends(lambda: MagicMock()))

def get_monitor_service_dependency():
    return Depends(lambda: MagicMock()))

current_dir = Path(__file__).resolve().parent
parent_dir = current_dir.parent.parent  # Go up two levels to reach project root
if str(parent_dir) not in sys.path:
    sys.path.insert(0, str(parent_dir))

# Import helper to fix path issues
from tests_dest.import_helper import fix_imports
fix_imports()
# Import helper to fix path issues

import pytest
import logging
from unittest.mock import MagicMock, AsyncMock, patch
from fastapi.testclient import TestClient
from fastapi import Request, Response, FastAPI, HTTPException

# Configure logging
logging.basicConfig()
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Optional imports - these might fail but won't break tests
try:
    from services.base_service import BaseService
    from services.monitor_service import MonitorService
    from models.base_model import BaseModel
except ImportError as e:
    logger.warning(f"Optional import failed: {e}")




    get_material_service_dependency,
    get_monitor_service_dependency
)
from services import get_material_service, get_monitor_service

# Simple controller function for testing
async def test_controller()
    request: Request,
    material_service = get_material_service_dependency(),
    monitor_service = get_monitor_service_dependency():
    """Simple controller function for testing dependency injection."""
    # Print diagnostic information
    print(f"Type of material_service: {type(material_service)}")
    print(f"Material service ID: {id(material_service)}")
    print(f"Type of monitor_service: {type(monitor_service)}")
    print(f"Monitor service ID: {id(monitor_service)}")
    
    # Return a simple response
    return JSONResponse({"status": "ok"})

# Diagnostic function to inspect the dependency functions
def inspect_dependency_functions():
    """Inspect the dependency functions to understand how they work."""
    print("\n--- Inspecting dependency functions ---")
    
    # Get the dependency functions
    material_dep_func = get_material_service_dependency
    monitor_dep_func = get_monitor_service_dependency
    
    # Print information about the dependency functions
    print(f"Material dependency function: {material_dep_func}")
    print(f"Monitor dependency function: {monitor_dep_func}")
    
    # Get the dependency objects
    material_dep = material_dep_func()
    monitor_dep = monitor_dep_func()
    
    # Print information about the dependency objects
    print(f"Material dependency object: {material_dep}")
    print(f"Material dependency object type: {type(material_dep)}")
    print(f"Monitor dependency object: {monitor_dep}")
    print(f"Monitor dependency object type: {type(monitor_dep)}")
    
    # Check what the dependency objects contain
    if hasattr(material_dep, "dependency"):
        print(f"Material dependency.dependency: {material_dep.dependency}")
        print(f"Material dependency.dependency type: {type(material_dep.dependency)}")
    
    if hasattr(monitor_dep, "dependency"):
        print(f"Monitor dependency.dependency: {monitor_dep.dependency}")
        print(f"Monitor dependency.dependency type: {type(monitor_dep.dependency)}")

# Diagnostic function to test patching at different levels
@pytest.mark.asyncio
async def test_patching_levels():
    """Test patching at different levels to understand where the issue is."""
    print("\n--- Testing patching at different levels ---")
    
    # Create mock services
    mock_material_service = MagicMock()
    mock_material_service.list_materials = MagicMock(return_value=["test_material"])
    mock_material_service.__class__.__name__ = "MockMaterialService"
    
    mock_monitor_service = MagicMock()
    mock_monitor_service.log_error = MagicMock()
    mock_monitor_service.__class__.__name__ = "MockMonitorService"
    
    # Create mock request
    mock_request = AsyncMock(spec=Request)
    
    # Test 1: Patch the service getter functions
    print("\nTest 1: Patch the service getter functions")
    with patch('services.get_material_service', return_value=mock_material_service), \
         patch('services.get_monitor_service', return_value=mock_monitor_service):
        
        # Check if the patched functions return our mocks
        service1 = get_material_service()
        service2 = get_monitor_service()
        print(f"Direct call to get_material_service returns: {service1}")
        print(f"Direct call to get_monitor_service returns: {service2}")
        
        # Call the controller
        try:
            result = await test_controller(mock_request)
            print(f"Controller result: {result}")
        except Exception as e:
            print(f"Controller raised exception: {type(e).__name__}: {str(e)}")
    
    # Test 2: Patch the dependency functions
    print("\nTest 2: Patch the dependency functions")
    with patch('controllers.material_common.get_material_service_dependency', return_value=mock_material_service), \
         patch('controllers.material_common.get_monitor_service_dependency', return_value=mock_monitor_service):
        
        # Check if the patched functions return our mocks
        dep1 = get_material_service_dependency()
        dep2 = get_monitor_service_dependency()
        print(f"Direct call to get_material_service_dependency returns: {dep1}")
        print(f"Direct call to get_monitor_service_dependency returns: {dep2}")
        
        # Call the controller
        try:
            result = await test_controller(mock_request)
            print(f"Controller result: {result}")
        except Exception as e:
            print(f"Controller raised exception: {type(e).__name__}: {str(e)}")
    
    # Test 3: Patch the Depends object's dependency attribute
    print("\nTest 3: Patch the Depends object's dependency attribute")
    material_dep = get_material_service_dependency()
    monitor_dep = get_monitor_service_dependency()
    
    original_material_dep = material_dep.dependency
    original_monitor_dep = monitor_dep.dependency
    
    try:
        # Try to modify the dependency attribute
        material_dep.dependency = lambda: mock_material_service
        monitor_dep.dependency = lambda: mock_monitor_service
        
        # Call the controller
        try:
            result = await test_controller(mock_request)
            print(f"Controller result: {result}")
        except Exception as e:
            print(f"Controller raised exception: {type(e).__name__}: {str(e)}")
    finally:
        # Restore original dependencies
        material_dep.dependency = original_material_dep
        monitor_dep.dependency = original_monitor_dep

# Run the diagnostic functions
inspect_dependency_functions()

if __name__ == "__main__":
    # Run the tests directly if this file is executed
    asyncio.run(test_patching_levels()) 
# Mock implementation of models.base_model
class BaseModel:
    """Mock base model class."""
    def __init__(self, **kwargs):
        for key, value in kwargs.items():
            setattr(self, key, value)
    
    def dict(self):
        return self.__dict__
